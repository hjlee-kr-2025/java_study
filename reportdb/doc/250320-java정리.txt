// 250320-java정리.txt
java 문법
1. 명령문끝에 ; 을 붙인다.
2. 모든 프로그램은 class 안에서 이루어진다.
3. 클래스위에 package 경로를 포함하고 있습니다.
4. 같은 패키지에는 동일한 이름의 클래스를 사용할 수 없습니다.
5. 같은 이름의 클래스여도 패키지가 다른면 다른 클래스입니다.
6. 다른클래스를 사용할때 패키지와 함께 import 하여 사용합니다.
7. 같은 패키지의 클래스는 import 하지 않고 사용할 수 있습니다.
8. java에 기본적으로 구현되어있는 클래스(라이브러리)도 import하여 사용합니다.
9. 예외) java.lang 패키지에 있는 클래스는 컴파일러가 자동으로 import합니다.
10. 클래스의 이름은 대문자로 시작합니다.
11. 패키지의 이름은 소문자로 구성합니다.
12. 기본자료형과 wrapper클래스
- 정수형 : byte, short, int, long : Byte, Short, Integer, Long
- 문자형 : char                   : Character
- 실수형 : float, double          : Float, Double
- 논리형 : boolean                : Boolean
13. 문자열 : String 클래스를 주로 사용합니다.

14. 조건문
if (조건) {참일때실행;} else {거짓일때 실행;}
(조건)?참일때실행:거짓일때실행;  ===> 3항연산자
-- if~else 문은 처리하고 끝.
-- 3항연산자는 처리한 내용을 변수에 저장할 수 있습니다.
	예) 변수 = (조건)?참:거짓;
	
switch(변수) {case 값1:break;}
-- switch 문은 변수값으로 처리하는 내용을 다르게 할때 사용하는 조건문입니다.
-- 주로 메뉴처리시 많이 사용합니다.

15. 반복문
while(조건) {참일때 반복;}
-- 프로그램의 무한반복을 실행할 때 while(true) {프로그램;} 으로 구성합니다.

for (1 ; 2; 4) {3;}
-- 1: for문 진입전 처리 : 주로 조건초기화에 사용
-- 2: 조건문(for문이 동작하는 조건)
-- 3: 참일때 처리하는 명령
-- 4: 3번처리후 조건에 비교값을 변화하는데 사용 (증감연산자를 많이 사용)

for (자료형 변수명 : 리스트<자료형> 변수) {
	변수명으로 하나씩 처리;
} ==> 향상된 for문

break;   => 반복문을 빠져나갈때
-- 정확한 사용법은 위로 거슬러 올라가면서 처음만나는 while, for, switch 블럭"{}"을
		빠져나가는 명령문입니다. 
continue;=> 반복문의 처음으로 이동시

16. 클래스
- 모든 자바프로그램은 한개 이상의 클래스를 가지고 있습니다.
- 클래스는 멤버변수 와 메서드(함수) 로 구성되어있습니다.
- 변수는 값을 저장하고 있는 것
- 메서드는 프로그램이 처리되는 곳
- 클래스를 사용하기위해서는 기본적으로 생성자를 사용해서 메모리할당을 해야합니다.
- static 으로 선언되어있는것은 생성자와 관계없이 메모리에 할당이 됩니다.

- 변수 : 자료형을 가지고 있습니다.
		변수선언시 (자료형 변수이름;) 으로 프로그래밍합니다.
		기본자료형과 참조자료형으로 나뉩니다.
		기본자료형은 8가지 외에 없습니다.
		참조자료형은 기본자료형외 모든자료형을 참조자료형이라고 합니다.
		참조자료형은 클래스자료형이라고도 부릅니다.
		모든 참조자료형을 포함할 수 있는 자료형은 Object 입니다.
		
- 메서드 (함수)
	형식 : 리턴자료형 함수이름(매개변수) { 처리문; return 리턴자료형의값;}
		* return 을 생략할 수 있는 유일한 리턴자료형은 void 입니다.
		* 리턴자료형이 void 로 되어있으면 return문이 없어나 return; 으로 
		리턴값없이 사용합니다.
		
- static 으로 선언한 변수, 메서드를 다른 클래스가 사용할때
	* 클래스이름.변수, 클래스이름.메서드(); 로 사용하면 됩니다.
	
- 생성자 : 클래스를 사용하려고 메모리 할당될때 실행되는 메서드
		* 리턴타입없이 클래스이름 그대로 사용합니다.
		* 클래스에 생성자가 하나도 구현되어있지 않으면 자바컴파일러는 기본생성자를 만들어줍니다.
		* 기본생성자: public 클래스이름() {}
		
- 접근제어자 : public, private, protected
		* public : 모든클래스에 접근 및 사용가능
		* private : 혼자쓴다.
		* protected : 자신과 상속받는(자녀)클래스에서 사용한다.
		* 접근제어자가 없으면 같은 패키지에 있는 클래스에서 접근,사용가능합니다.
		* 변수는 private으로, 메서드는 public으로 많이 구현되어있습니다.
		
- this : 클래스자신의미(할당된)
		* 메서드에서 지역변수와 멤버변수의 이름이 같을때 멤버변수를 사용하려면
			this.변수명 으로 사용합니다.

- 상속, 추상클래스, 인터페이스
	*  상속: 자녀클래스(상속받는클래스)가 부모클래스(상속을주는클래스)의 멤버변수
			메서드를 자기클래스에서 선언된것과 동일하게 사용가능하도록 해주는 것입니다.
			메서드는 자녀클래스 입맛대로 내용(구현되어있는부분)을 자유롭게 변형도 가능합니다.
			-- 오버라이팅!! @Override 는 이 메서드는 부모클래스에서 선언한 메서드라고
			컴파일러에 알려줘서 부모클래스에 존재하지 않는 메서드를 사용하면 컴파일러가
			Error를 알려줍니다. 
				==> 메서드이름, 리턴자료형, 매개변수자료형과 개수가 동일해야합니다.
	*  상속을 사용하는 또 다른 이유
			- 다형성을 위해서
			- 동일한 부모클래스를 상속받는 서로다른 자녀클래스들은
					부모클래스로 선언하고
					생성을 자녀클래스로 해서 사용할 수 있습니다.
						
	*  추상클래스 ---> 인터페이스
			- 추상클래스
				* abstract 예약어로 선언한 클래스 : class abstract 클래스이름 {}
				* 추상메서드를 선언할 수 있습니다.
					- 추상메서드는 abstract 예약어를 사용한 메서드인데 선언만하고,
						블럭{}(처리문)이 없는 메서드입니다.
					- 선언 : public abstract 리턴자료형 함수이름(매개변수); 
				* 생성자를 사용할 수 없습니다.
				* 추상클래스의 사용은 상속을 줘서 자녀클래스에서 사용하도록 처리합니다.
					- 자녀클래스는 선언만된 메서드를 반드시 구현한 후 사용할 수 있습니다.
						(부모클래스의 abstract 메서드를 오버라이드하여 사용합니다)
			- 인터페이스
				* 선언 : interface 클래스이름 {}
				* 메서드는 추상메서드만 사용할 수 있습니다. - 구현하면 error
					--> 추상메서드의 예약어 abstract 를 생략할 수 있습니다.
				* 인터페이스에서 선언된 멤버변수는 static final 처리가 됩니다.(상수)
	* 상속할 때 예약어 : extends, implements
		-- extends 
				: 클래스가 클래스(추상클래스포함)를 상속할 때 사용
				: 인터페이스가 인터페이스를 상속할 때 사용
		-- implements
				: 클래스가 인터페이스를 상속
		-- 클래스는 한 개만 상속받을 수 있습니다.(부모클래스가 클래스이면 하나만)
		-- 인터페이스는 여러개 동시에 상속이 가능합니다.
		-- 하나의 클래스와 여러개의 인터페이스를 동시에 상속받는것도 가능합니다.
			선언-예) class 클래스이름 extends 부모클래스 implements 인터페이스1,인터페이스2 {}

- 데이터 처리 : List, Map 인터페이스
	* List : ArrayList 클래스 - 하나의 자료형을 순서대로 저장 - 인덱스를 활용해서 사용
	* Map : HashMap 클래스
		- <Key, Value> 의 쌍으로 저장을 합니다.
		- Key는 중복된 값을 사용할 수 없습니다.
		- Value를 찾을 때 Key값을 사용합니다.
		- HashMap<Object, Object> 형태로 사용하면 json에 대응할 수 있습니다.
		
- 예외처리 
	* try {} catch (Exception e) {} finally {}
	* Exception 클래스 -> 예외처리클래스의 최상위 클래스
	* e.printStackTrace(); --> 예외발생사항을 순서대로 보여줍니다.
	* 예외처리를 메서드를 호출한 곳으로 넘기는 예약어 : throws
		
	
				
			







