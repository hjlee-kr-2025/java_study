자바
자료형(기본자료형 8가지)
- byte, short, int, long, char, float, double, boolean

연산자
- 산술연산자 (5가지)
- 비교연산자 (6가지)
- 논리연산자 (3가지)

조건문
if() {
}
else if () {
}
else {
}

switch (){
case xx:
	break;
default:
}

반복문
while() {
}
do {
} while() ;
for (1 ; 2; 4) {
}
for (배열자료형 변수명 : 배열변수명) {
}

클래스 : 자바는 클래스안에서 프로그램이 실행됩니다.
클래스안에
public static void main(String[] args) {
	//메인함수가 자바에서 프로그램이 실행되는 부분입니다.
}

- 멤버변수, field : 값, 속성을 저장하는 곳
- 메서드 (함수) : 동작(처리)에 관련된 것
- 클래스를 사용하려면 생성을 해야합니다. new 생성자() 로 생성
- 클래스안에 생성자를 개발자가 구현하지 않으면 컴파일러가 기본생성자를
자동으로 만들어줍니다.
(기본생성자)
public 클래스이름() {}
- 생성자를 사용할 때는 클래스에 구현한 파라메터개수를 맞춰서 써야합니다.

static 으로 선언한 변수, 함수는 생성하지 않고 사용합니다.
사용시 클래스이름.변수명, 클래스이름.함수명() 으로 사용하시면 됩니다.

배열 : 순서있게 데이터를 보관하고 처리하는 것
* 선언은 아래와 같이 할 수 있습니다.
자료형[] 변수명 = new 자료형[저장개수];
* 선언 + 초기화는 아래와 같이 할 수 있습니다.
자료형[] 변수명 = {값1, 값2, 값3, ...};
- 배열은 처음만들때 저장공간개수가 정해져있습니다.
그래서 가득찼을때 추가로 데이터 저장하기가 힘듭니다.
==> 데이터 추가/삭제를 자유롭게 하기 위해서
ArrayList 클래스를 만들었습니다.
*선언하고 생성하는 방법
import java.util.ArrayList;
ArrayList<자료형> 변수명 = new ArrayList<자료형>();
- 이클립스에서 ArrayList 사용할때
ArrayL 까지 타이핑하시고 [Ctrl]+[space] 누르고,
java.util에 있는 ArrayList를 선택하시면 자동으로 import합니다.

java.lang 에 있는 클래스는 import하지 않아도 컴파일러가 자동으로
import하지만 다른 패키지의 클래스는 import하고 사용해야 합니다.

클래스는 상속을 할 수 있습니다.
- 상속받는 클래스는 상속된 클래스의 멤버변수, 메서드를 자유롭게 사용할 수 있습니다.
- 메서드는 재정의해서 사용할 수도 있습니다.

다형성을 위해서
부모클래스로 선언하고 자녀클래스로 생성할 수 있습니다.
이때 자녀클래스에만 존재하는 멤버변수, 메서드를 사용하려면
다운캐스팅 해야 합니다.
부모클래스가 자녀클래스로 생성되었는지 확인하는 예약어 instanceof 가 있습니다.


*** 추상클래스 *** - abstract
public abstract class 클래스명 {
}

-- 추상메서드가 존재할 수있는 클래스입니다.
-- 추상메서드란? 처리문이 구현되어있지 않고 선언만 되어있는 메서드를 말합니다.
public abstract 함수명();


-- 추상클래스는 생성자가 없습니다.
-- 추상클래스는 상속을 주는 클래스이고 상속받은 클래스에서 구현안된 메서드를
구현하고 사용합니다.

-- final 예약어 - 변수, 메서드, 클래스
* 변수에 쓰이면? 상수로 사용합니다.
* 메서드에 쓰이면? 자녀클래스에서 재정의할 수 없습니다.
* 클래스에 쓰이면? 상속자체가 안됩니다.

((( 인터페이스 ))) - interface
-- 추상메서드로만 구현된 클래스입니다.
-- class 대신 interface 예약어를 사용합니다.
public interface 클래스명 {
}
-- 메서드 선언시 abstract 예약어를 생략할 수 있습니다.

클래스가 클래스를 상속시 extends 예약어 사용
인터페이스가 인터페이스 상속시 extends 예약어 사용
클래스가 인터페이스를 상속시 implements 예약어 사용

- 클래스는 1개만 상속을 준다.
- 인터페이스는 여러개 상속하는 것도 가능

- 인터페이스에서 변수를 선언하면?
자동으로 final static 변수가되어 상수로 사용됩니다.

(((( Object 클래스 ))))
- 모든 클래스의 최상위(부모 또는 조상) 클래스 입니다.
- toString() : 참조변수이름 다음처럼 println(참조변수이름) 사용하면
toString() 메서드가 실행됩니다.
	Object클래스에 구현된 toString()는
	"패키지.클래스이름@참조주소값" 을 String(문자열)로 리턴합니다.
- equals() : 두 클래스가 참조주소값이 같은지 확인하는 메서드
- clone() : 클래스의 깊은 복사(주소를 생성후 데이터복사) 가 되게하는 메서드입니다.

(((( String 클래스 ))))
- 문자열을 저장하고 처리하는 클래스입니다.
- 문자열을 저장하는 멤버변수가 final로 되어있습니다.
- 문자열의 내용을 변경하면 새로 생성하고 값은 넣습니다.
- 값을 자주 변경하는 문자열을 사용시에는 StringBuffer, StringBuilder를
사용합니다.
- toString() : 문자열데이터를 리턴하도록 재정의 되어있습니다.
- equals() : 데이터내용이 같으면 true를 리턴하도록 재정의 되어있습니다.

문자열을 나타낼때 : "문자열데이터"
문자열블럭 : 여러줄의 문자열을 하나의 변수에 저장할 때 사용
"""
문자열 첫번째줄
문자열 두번째줄
"""
-- 양쪽에 큰따옴표 3개씩 묶어서 사용하면 됩니다.

(((( Class 클래스 ))))
Class.forName() - static메서드
()안에 패키지와 클래스이름이 들어갑니다.
- 클래스를 찾아서 변수에 저장합니다.

제네릭 - 여러자료형을 사용할 수 있도록 하는 것.

컬렉션 프레임워크 - 자료를 관리하는 클래스, 인터페이스
*Collection - 하나의 자료형으로 저장
	-	List : 순서가 있는
	-	Set : 순서가 없는
*Map - Key, Value 쌍으로 저장
 


















