변수 - 기본자료형(4종류 8가지)
- byte, short, int, long, char, float, double, boolean

연산자
- 산술연산자 : + - * / %
- 비교연산자 : > >= < <= == !=
- 논리연산자 : && || !
- 대입연산자 : =

조건문
- if , if~else, if~else if~else
- switch~case~break

반복문
- while
- do~while
- for

자바 파일의 기본구조
- 파일이름: 클래스이름.java
- 자바파일이 위치한 곳: package (폴더)
- 자바프로젝트를 생성하면 src폴더가 생깁니다.
	=> src 폴더 아래에 pagkage를 만듭니다.
	=> pagkage 안에 java파일을 만들어 사용하게 됩니다.
- 자바파일내용
package 패키지이름;

public class 클래스이름 {
	// 멤버변수
	public 자료형 변수이름;
	private 자료형 변수이름;
	
	// 생성자
	public 클래스이름() {
	}
	
	// 메서드
	public 리턴자료형 메스드이름() {
		처리문;
		return 리턴값;
	} 
} // 클래스 끝

* 메서드 구성시 리턴자료형 자리에 자료형이름이 반드시 쓰여져야합니다.
==> 리턴값이 없는 메서드 ==> 리턴자료형에 void 를 적습니다.
==> 리턴값의 자료형과 리턴자료형은 같아야 합니다.

* 생성자
클래스 이름으로 되어있는 함수의 한종류라고 생각하시면됩니다.
- 리턴자료형은 생략합니다.
- 생성자를 개발자가 하나도 구현하지 않으면 컴퍼일러가 기본생성자를 자동으로
	만들어 줍니다.
	기본생성자의 모양은 아래와 같습니다.
	public 클래스이름() {}
- 클래스를 사용하려고 하면 생성자를 통해서 메모리를 할당해야 합니다.
	이때, 멤버변수의 값은 초기화됩니다.
- 생성자는 매개변수의 개수가 다른 여러가지 생성자를 만들 수 있습니다.
	=> 생성자 오버로드 라고 합니다.
- 클래스를 생성자를 통해서 메모리 할당할때 구현되어있는 생성자만 사용할 수 있습니다.

this 예약어 : 클래스 자기자신
super 예약어 : 부모 클래스를 지칭합니다.	

static 예약어
- static은 변수나 메서드앞에 사용할 수 있습니다.
- 생성하는 것과 상관이 없습니다.
- 자동으로 메모리할당을 합니다.
- 다른클래스에서 사용시 클래스변수명이 아닌
	 클래스명.스태틱변수;
	 클래스명.스태틱함수();
	로 사용하면 됩니다.

배열
- 자료를 순차적으로 저장/관리하기 위한 구조
- 자바에서는 같은자료형으로만 배열을 만들수 있습니다.
- 인덱스와 함께 사용합니다. 인덱스는 저장위치를 나타내고 0부터 시작합니다.
(배열공간이 10개라면, 인덱스는 0부터 9까지 있습니다)
- 배열의 선언
1. 자료형[] 배열변수이름 = new 자료형[배열개수];
2. 자료형 배열변수이름[] = new 자료형[배열개수];
- 배열의 선언과 동시에 초기화
자료형[] 배열변수이름 = {값1, 값2, 값3, ...};
: 값의 자료형은 선언한 자료형이어야 합니다.
- 배열의 사용
배열변수이름[인덱스] 로 사용하시면 됩니다.
- 배열의 특징중 하나는 저장공간을 미리 정해야 합니다.
==> 배열의 저장과 삭제를 자유롭게 배열의 처리를 쉽게 하기위해
==> ArrayList 클래스를 만들었습니다.
((( ArrayList )))
- import java.util.ArrayList; 로 임포트해서 사용해야 합니다.
- 자바에서 클래스를 사용할 때 같은 패키지에 속해있는 클래스가 아니면
	import 해서 사용해야합니다.
- 예외) java.lang 패키지에 속해있는 클래스는 import 하지 않아도
	사용할 수 있습니다.
- 이클립스에서 클래스를 사용할때 클래스이름을적고 [Ctrl]+[Space] 를
	누르면 자동으로 import 할 수 있습니다.
- 선언하고 메모리할당하는 방법
ArrayList<자료형> 변수이름 = new ArrayList<자료형>();
1. 데이터추가
	변수이름.add(값);
2. 데이터삭제 - 데이터가 삭제되고, 리턴값으로 삭제되는 데이터값을 돌려줍니다.
	변수이름.remove(인덱스);
3. 데이터가져오기 - 데이터는 삭제되지 않습니다.
	변수이름.get(인덱스);
4. 저장된 데이터 개수리턴
	변수이름.size();
5. 비어있는지 확인 : 비어있으면 true
	변수이름.isEmpty();
	
((( 상속 )))
: 부모클래스를 내 것처럼 사용하고 싶다.
- 상속받은 클래스는 부모클래스의 멤버변수, 메서드를 제약없이 사용할 수 있습니다.
- 메서드 오버라이드
	: 부모클래스의 메서드를 상속받는 자녀클래스가
	 재정의(함수내용의 프로그램을 다시하는것) 할 수 있는것.
- 다형성
	: 부모클래스로 선언하고 자녀클래스로 생성하는것
	: 서로 다른 자녀클래스로 생성한 데이터를 배열 또는 ArrayList에
	함께 저장해서 관리할 수 있습니다.
- 다운캐스팅
	: 생성한 자료형으로만 다운캐스팅 할 수 있습니다.
	: 이 클래스로 생성했는 확인하기 위한 예약어 - instanceof
	// 아래의 코드는 클래스이름으로 생성한것인지 확인하고
	// 다운캐스팅까지 해준 코드입니다.
	if (부모클래스변수명 instaceof 자녀클래스이름 변수명) {
		클래스이름으로 생성이 되었으면
		변수명으로 자녀클래스안에 내용을 사용할 수 있습니다.
	}
	====> 아래 구현한 코드와 동일합니다.
	if (부모클래스변수명 instanceof 자녀클래스이름) {
		자녀클래스이름 변수명 = (자녀클래스이름) 부모클래스변수명;// 다운캐스팅
	}

((( 추상클래스 ))) - abstract
- 클래스를 만들때 abstract 클래스이름앞에 적어준 것
- abstract 를 왜 적어줬을까?
- 메서드중에 abstract 메서드가 있기 때문에
- abstract 메서드: 구현부없이 선언만 있는 메서드
예) public abstract void showInfo();
- 부모클래스가 주제만 정해주고, 내용은 자녀클래스가 알아서 만들어라.
* 추상클래스 특징
- 1. 생성자가 없습니다.
- 2. 부모클래스로 사용이 됩니다.
- 3. 추상클래스를 사용하는 대표적인 코딩방식 : 탬플릿메서드

* final 예약어
- 변수, 메서드, 클래스에 사용할 수 있습니다.
- 변수에 사용하면 상수로 만들어 줍니다.(값을 수정할 수 없습니다)
- 메서드에 사용하면 오버라이드를 할 수 없습니다.
- 클래스에 사용하면 상속할 수 없습니다.

((( 인터페이스 )))
- 1. 모든 메서드가 추상(abstract) 메서드입니다
- 2. 모든 변수는 상수가 됩니다. (변수선언시 final static 이 자동으로 추가됩니다)
- 3. 인터페이스를 클래스가 상속받을때는 implements 예약어를 사용합니다.
- 4. 인터페이스를 인터페이스가 상속받을때는 extends 예약어를 사용합니다.
- 5. 인터페이스도 생성자가 없습니다.
- 6. 메서드 선언시 abstract 예약어를 생략할 수 있습니다.
- 7. 구현할 수 메서드는 default, static 메서드가 있습니다.
- 8. 인터페이스를 상속받은 클래스를 이클립스에서 만들때 상속받을 인터페이스를
	지정하면 구현안된 메서드들을 자동으로 완성해서 파일을 만들어 줍니다.
	
JDK 기본클래스
**** Object 클래스 - 모든클래스의 부모(조상)클래스
toString();
- 우리가 System.out.println(객체자료형변수명);
	패키지와 클래스명 @ 참조주소값
==> 이때 실행되는 메서드가 toString() 메서드입니다.
equals();
- 참조주소를 비교해서 같으면 true를 리턴합니다.
==> String 클래스는 equals() 메서드를 재정의해서 문자열이 같은지를 체크합니다.
clone(); - 깊은복사를 지원하는 메서드
- 생성해서 기존 데이터를 복사합니다.


ch12. 컬렉션 프레임워크
- 데이터를 효율적으로 저장하고 관리하는 인터페이스, 클래스들의 집합

- 변수는 자료형 (기본자료형8가지 또는 클래스(객체)자료형)
- ArrayList<E> 라고 표현되어 있어서 <> 안에 자료형을 자유롭게
정의하고 사용할 수 있도록 하는 것을 "제네릭"이라고 합니다.

*** 두가지 계열의 인터페이스
1. Collection 인터페이스 기반으로 만들어진 것
- 자료가 하나
=== 두가지 종류로 나뉩니다.
** 순서가 있는 자료형 - List 인터페이스
- ArrayList
** 순서가 없는 자료형 - Set 인터페이스
2. Map 인터페이스 기반으로 만들어진 것 
- Key, Value의 쌍으로 데이터가 저장됩니다.


** Collection 인터페이스
- add(값) : 값을 추가할 때
- remove() : 값을 삭제할 때
- clear() : 전체 데이터 삭제
- size() : 저장된 데이터 개수를 리턴

** Map 인터페이스
- put(key, value) : 값을 추가할 때
- get(key) : key값으로 value를 가져옵니다.
- isEmpty() : 비어있는지 리턴
- keyset() : key값을 Set 자료형으로 반환합니다.
- remove(key) : key값으로 데이터를 지웁니다.

 





 
	
	




























