자바: 클래스를 사용해서 프로그래밍이 됩니다.
public class 클래스명 {
	public static void main (String[] args) {
		이곳에 작성한 프로그램이 실행됩니다.
	}
}

자바에서 값을 저장하고 있는것 - 변수 ==> 자료형: 기본자료형, 참조(클래스)자료형
기본자료형(8가지)
byte, short, int, long, char, float, double, boolean
기본자료형을 가지고 만든 참조자료형 8가지 (Wrapper 클래스)
Byte, Short, Integer, Long, Character, Float, Double, Boolean

문자열을 위한 클래스
String


((( 연산자 )))
* 산술연산자: 계산위해서 사용하는 연산자
 : +, -, *, /, %
* 증감연산자: 주로 반복문과 함께 사용되는 연산자
 : ++, --
* 비교연산자: 두값의 크기를 비교합니다.(값의 순서를 비교)
 => 비교연산후 결과값은 true / false
 => 조건문과 함께 많이 사용되는 연산자.
 : >, >=, <, <=, ==, != (6가지)
* 논리연산자
 : AND, OR, NOT
 : && , ||, !
* 대입연산자 : = : 오른쪽값을 왼쪽에 대입한다는 의미로 사용됩니다.
* 복합연산자
	a += b; ===> a = a + b;
	: +=, -=, *=, /=, %=   

((( 조건문 ))) : if , switch
* if : true 와 false 를 기준으로 처리하는 조건문입니다.
if (조건1) {
	조건1참일때 처리
}
else if (조건2) {
	조건1거짓, 조건2참일때 처리
}
else {
	조건1, 조건2가 모두 거짓이면 처리
}
* switch : 값이 같은것을 이용하여 처리하는 조건문입니다.
==> 메뉴구성시 많이 사용됩니다.
==> 자바의 switch는 문자열이 같은것도 처리가 됩니다.
switch (변수명) {
case 값1:
	변수값 == 값1 일때 처리
	break; case 값1 부분을 처리하고 switch블럭을 빠져나옵니다.
case 값2:
	변수값 == 값2 일때 처리
	break;	
default:
	변수값이 case 에 적인 값이 아닐때 이곳이 처리
}
** break; 문은 코드를 위로 올라가면서 가장처음만나는
 switch, while, for 블럭{}을 빠져나옵니다. 	

((( 반복문 ))) : while, do~while, for
* while : 조건이 참인동안 반복하는 명령문
while (조건) {
	조건이 참일때 처리문;
	모두 실행후 while()로 갑니다.
}
* do~while : 처음한번은 무조건 실행되고, 조건이 참이면 계속반속
do {
	1. 처음 실행
	2. while(조건) 참 => 반복실행
} while (조건);
* for : 순서있는 반복문처리에 유용하도록 설계
-- 일반 for 
for (1.초기화 ; 2.조건 ; 4.증감) {
	3.처리문
}
-- 향상된 for 문
주로 배열과 함께
for (배열자료형 변수명 : 배열변수명) {
	변수명으로 처리;
}
==> collection 인터페이스를 상속받은 클래스자료형도 사용할 수 있습니다.

클래스이름.java 안에 소스가 구현되어있습니다.
public class 클래스이름 {
	멤버변수 - 데이터 저장/관리
	
	생성자 - 클래스를 사용하고자 할당할때 - 멤버변수 초기화와 함께 진행
	
	메서드 - 프로그램 실행 / 처리에 관련된 내용
}
** 메서드 (함수)
리턴자료형 함수이름 (매개변수) {
	처리하는 내용
	return 데이터;
}
==> 데이터는 리턴자료형의 데이터를 사용해야 합니다.
==> return 데이터가 없으면?
리턴자료형에 void 를 적고 함수안에 return은 생략해도 됩니다.
return; 처럼 데이터 없이 사용해야 합니다.

return 의 의미는 함수가 끝났다는 의미로도 사용됩니다.
 

** 생성자
- 클래스내에 생성자가 구현되어 있어야 클래스를 new로 할당해서 사용할 수 있습니다.
- 클래스에 생성자가 없으면 JAVA가 기본생성자를 만들어 줍니다.
- 기본생성자는 public 클래스이름() {} 의 형태를 갖습니다.
- 클래스를 생성자로 할당할때 생성자로 구현되어있는 형식으로만 사용할 수 있습니다.
- 생성자는 여러개의 생성자를 만들수 있습니다.(오버로드)

** 접근제어자 : public, private, protected
- public 은 모든 클래스에서 직접접근이 가능합니다.
- 클래스 안에 있는 변수나 메서드를 직접접하는 방식은
	변수명.변수, 변수명.메서드() 를 사용합니다. '.' 으로 접근
	System.out.println();
	==> System 클래스의 out 클래스변수에 있는
	println() 메서드를 실행한다는 의미입니다.
- private 은 클래스 내부(자기자신클래스) 에서만 사용가능한 접근제어자 입니다.
- protected 는 자신과 자녀(상속받는클래스)에게만 직접접근을 허용합니다.

- 멤버변수에는 주로 private이나 protected를 사용하는데 간접적으로
접근해서 사용할 수 있도록 하는것이 getter, setter 입니다.
private int studentNo;
getter
=>
public int getStudentNo () {
	return studentNo;
}
setter
==>
public void setStudentNo(int studentNo) {
	this.studentNo = studentNo;
}

** this : 클래스자신을 의미합니다.
- 지역변수와 멤버변수의 이름이 같을때 멤버변수를 표현하려면
this.멤버변수 로 사용합니다.

** static : 변수, 메서드
==> static으로 선언한 변수 또는 메서드는 생성하지 않고도 사용할 수 있습니다.
클래스이름.static변수;
클래스이름.static메서드(); 

배열 / ArrayList
* 배열 
- 같은 자료형의 데이터를 순서를 가지고 저장/관리하는 형태입니다.  
- 관리할 자료의 개수가 배열을 생성할 때 정해집니다.
- 유효한 데이터 개수를 확인할 때는 별도의 변수가 필요합니다.
- 배열의 크기를 알려주는 것은
	배열변수명.length 인데 이때 유효한 데이터가 아닌 방의 크기를 알려줍니다.
====> 여러가 불편을 해소한 클래스 => ArrayList
* ArrayList
- 데이터 추가 : add()
- 데이터 삭제 : remove()
- 데이터 개수확인 : size() : 저장된 유효 데이터를 리턴합니다.
- 데이터 값 확인 : get()
* 제네릭 : 다양한 자료형의 데이터를 사용할 수 있도록 하는 방법
=> 개발자가 원하는 데이터자료형을 사용할 수 있도록 해줍니다.
컬렉션프레임워크 (데이터를 관리하고 사용하기 위한 class 집합)
- collection 인터페이스 : 자료형 하나씩 저장하고 관리
	: List 인터페이스 ---> ArrayList<E> 클래스
	: Set 인터페이스
- map 인터페이스 : <Key, Value> 쌍으로 저장하고 관리
	: HashMap 클래스를 주로 사용합니다.
	: 데이터를 사용 또는 처리할때 key(유일한값) 을 사용합니다.












